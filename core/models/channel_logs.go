package models

import (
	"context"
	"encoding/json"
	"fmt"
	"path"
	"time"

	"github.com/nyaruka/gocommon/dates"
	"github.com/nyaruka/gocommon/httpx"
	"github.com/nyaruka/gocommon/jsonx"
	"github.com/nyaruka/gocommon/storage"
	"github.com/nyaruka/gocommon/stringsx"
	"github.com/nyaruka/gocommon/uuids"
	"github.com/nyaruka/goflow/assets"
	"github.com/nyaruka/mailroom/runtime"
	"github.com/pkg/errors"
)

// ChannelLogID is our type for a channel log id
type ChannelLogID int64

// ChannelLogUUID is our type for a channel log UUID
type ChannelLogUUID uuids.UUID

type ChannelLogType string

const (
	ChannelLogTypeIVRStart    = "ivr_start"
	ChannelLogTypeIVRIncoming = "ivr_incoming"
	ChannelLogTypeIVRCallback = "ivr_callback"
	ChannelLogTypeIVRStatus   = "ivr_status"
	ChannelLogTypeIVRHangup   = "ivr_hangup"
)

type ChannelError struct {
	Message string `json:"message"`
	Code    string `json:"code"`
}

func NewChannelError(message, code string) ChannelError {
	return ChannelError{Message: message, Code: code}
}

// ChannelLog stores the HTTP traces and errors generated by an interaction with a channel.
type ChannelLog struct {
	uuid      ChannelLogUUID
	type_     ChannelLogType
	channel   *Channel
	httpLogs  []*httpx.Log
	errors    []ChannelError
	createdOn time.Time
	elapsed   time.Duration

	recorder *httpx.Recorder
	redactor stringsx.Redactor
	attached bool
}

// NewChannelLog creates a new channel log with the given type and channel
func NewChannelLog(t ChannelLogType, ch *Channel, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, nil, redactVals)
}

// NewChannelLogForIncoming creates a new channel log for an incoming request
func NewChannelLogForIncoming(t ChannelLogType, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, r, redactVals)
}

func newChannelLog(t ChannelLogType, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return &ChannelLog{
		uuid:      ChannelLogUUID(uuids.New()),
		type_:     t,
		channel:   ch,
		httpLogs:  []*httpx.Log{},
		errors:    []ChannelError{},
		createdOn: dates.Now(),

		recorder: r,
		redactor: stringsx.NewRedactor("**********", redactVals...),
	}
}

func (l *ChannelLog) UUID() ChannelLogUUID { return l.uuid }

func (l *ChannelLog) HTTP(t *httpx.Trace) {
	l.httpLogs = append(l.httpLogs, l.traceToLog(t))
}

func (l *ChannelLog) Error(err error) {
	l.errors = append(l.errors, NewChannelError(err.Error(), ""))
}

func (l *ChannelLog) End() {
	if l.recorder != nil {
		// prepend so it's the first HTTP request in the log
		l.httpLogs = append([]*httpx.Log{l.traceToLog(l.recorder.Trace)}, l.httpLogs...)
	}

	l.elapsed = time.Since(l.createdOn)
}

func (l *ChannelLog) traceToLog(t *httpx.Trace) *httpx.Log {
	return httpx.NewLog(t, 2048, 50000, l.redactor)
}

// if we have an error or a non 2XX/3XX http response then log is considered an error
func (l *ChannelLog) isError() bool {
	if len(l.errors) > 0 {
		return true
	}

	for _, l := range l.httpLogs {
		if l.StatusCode < 200 || l.StatusCode >= 400 {
			return true
		}
	}

	return false
}

const sqlInsertChannelLog = `
INSERT INTO channels_channellog( uuid,  channel_id,  log_type,  http_logs,  errors,  is_error,  elapsed_ms,  created_on)
                         VALUES(:uuid, :channel_id, :log_type, :http_logs, :errors, :is_error, :elapsed_ms, :created_on)
  RETURNING id`

// channel log to be inserted into the database
type dbChannelLog struct {
	ID        ChannelLogID    `db:"id"`
	UUID      ChannelLogUUID  `db:"uuid"`
	ChannelID ChannelID       `db:"channel_id"`
	Type      ChannelLogType  `db:"log_type"`
	HTTPLogs  json.RawMessage `db:"http_logs"`
	Errors    json.RawMessage `db:"errors"`
	IsError   bool            `db:"is_error"`
	ElapsedMS int             `db:"elapsed_ms"`
	CreatedOn time.Time       `db:"created_on"`
}

// channel log to be written to logs storage
type stChannelLog struct {
	UUID        ChannelLogUUID     `json:"uuid"`
	Type        ChannelLogType     `json:"type"`
	HTTPLogs    []*httpx.Log       `json:"http_logs"`
	Errors      []ChannelError     `json:"errors"`
	ElapsedMS   int                `json:"elapsed_ms"`
	CreatedOn   time.Time          `json:"created_on"`
	ChannelUUID assets.ChannelUUID `json:"-"`
}

func (l *stChannelLog) path() string {
	return path.Join("channels", string(l.ChannelUUID), string(l.UUID[:4]), fmt.Sprintf("%s.json", l.UUID))
}

// InsertChannelLogs writes the given channel logs to the db
func InsertChannelLogs(ctx context.Context, rt *runtime.Runtime, logs []*ChannelLog) error {
	attached := make([]*stChannelLog, 0, len(logs))
	unattached := make([]*dbChannelLog, 0, len(logs))

	for _, l := range logs {
		if l.attached {
			// if log is attached to a call or message, only write to storage
			attached = append(attached, &stChannelLog{
				UUID:        l.uuid,
				Type:        l.type_,
				HTTPLogs:    l.httpLogs,
				Errors:      l.errors,
				ElapsedMS:   int(l.elapsed / time.Millisecond),
				CreatedOn:   l.createdOn,
				ChannelUUID: l.channel.UUID(),
			})
		} else {
			// otherwise write to database so it's retrievable
			unattached = append(unattached, &dbChannelLog{
				UUID:      ChannelLogUUID(uuids.New()),
				ChannelID: l.channel.ID(),
				Type:      l.type_,
				HTTPLogs:  jsonx.MustMarshal(l.httpLogs),
				Errors:    jsonx.MustMarshal(l.errors),
				IsError:   l.isError(),
				CreatedOn: l.createdOn,
				ElapsedMS: int(l.elapsed / time.Millisecond),
			})
		}
	}

	if len(attached) > 0 {
		uploads := make([]*storage.Upload, len(attached))
		for i, l := range attached {
			uploads[i] = &storage.Upload{
				Path:        l.path(),
				ContentType: "application/json",
				Body:        jsonx.MustMarshal(l),
			}
		}
		if err := rt.LogStorage.BatchPut(ctx, uploads); err != nil {
			return errors.Wrapf(err, "error writing attached channel logs to storage")
		}
	}

	if len(unattached) > 0 {
		err := BulkQuery(ctx, "insert channel log", rt.DB, sqlInsertChannelLog, unattached)
		if err != nil {
			return errors.Wrapf(err, "error inserting unattached channel logs")
		}
	}

	return nil
}
